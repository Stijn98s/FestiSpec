/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v12.0.12.0 (NJsonSchema v9.13.15.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import type = Mocha.utils.type;
export class AuthClient {
    private url: any;
    constructor (defaultUrl: string) {
      this.url = defaultUrl;
    }

    getBaseUrl (defaultUrl: string) {
      return this.url
    }

    transformHttpRequestOptions (options: RequestInit): Promise<RequestInit> {
      if (options.headers) {
        (<any>options.headers)['Authorization'] = 'Bearer ' + localStorage.getItem('token')
      }

      options.mode = 'cors'
      return Promise.resolve(options)
    }
}

export class ApiClientBase {
  constructor (private authClient: AuthClient) {

  }
    protected _loginAttempts = 0;
    getBaseUrl (defaultUrl: string) {
      return this.authClient ? this.authClient.getBaseUrl(defaultUrl) : defaultUrl
    }

    transformOptions (options: RequestInit): Promise<RequestInit> {
      return this.authClient ? this.authClient.transformHttpRequestOptions(options) : Promise.resolve(options)
    }

    protected transformResult (url: string, response: Response, processor: (response: Response) => any) {
      if (response.status == 401) {
        this._loginAttempts += 1
        if (this._loginAttempts >= 3) {
          localStorage.removeItem('token')
          localStorage.removeItem('vuex')
          this._loginAttempts = 0
        }
      }
      return processor(response)
    }
}

export class AvailabilityClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    get(): Promise<Availability[] | null> {
        let url_ = this.baseUrl + "/api/Availability";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<Availability[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Availability.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Availability[] | null>(<any>null);
    }

    create(availability: Availability): Promise<Availability | null> {
        let url_ = this.baseUrl + "/api/Availability";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(availability);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<Availability | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Availability.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Availability | null>(<any>null);
    }

    edit(availabilityPosted: Availability): Promise<Availability | null> {
        let url_ = this.baseUrl + "/api/Availability";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(availabilityPosted);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<Availability | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Availability.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Availability | null>(<any>null);
    }

    create2(): Promise<void> {
        let url_ = this.baseUrl + "/api/Availability/Create";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate2(_response));
        });
    }

    protected processCreate2(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(<any>null);
    }
}

export class DrawAnswerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    get(id: string | null): Promise<DrawQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/DrawAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<DrawQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrawQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DrawQuestionAnswer | null>(<any>null);
    }

    create(id: string | null, answer: DrawQuestionAnswer): Promise<DrawQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/DrawAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<DrawQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrawQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DrawQuestionAnswer | null>(<any>null);
    }

    edit(id: string | null, answerposted: DrawQuestionAnswer): Promise<DrawQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/DrawAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answerposted);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<DrawQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrawQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DrawQuestionAnswer | null>(<any>null);
    }
}

export class EventClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    getAll(): Promise<Event[] | null> {
        let url_ = this.baseUrl + "/api/Event";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<Event[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Event.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Event[] | null>(<any>null);
    }

    get(id: string | null): Promise<Event | null> {
        let url_ = this.baseUrl + "/api/Event/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<Event | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Event.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Event | null>(<any>null);
    }

    getQuestionnaires(id: string | null): Promise<Questionnaire[] | null> {
        let url_ = this.baseUrl + "/api/Event/{id}/Questionnaires";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetQuestionnaires(_response));
        });
    }

    protected processGetQuestionnaires(response: Response): Promise<Questionnaire[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Questionnaire.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Questionnaire[] | null>(<any>null);
    }
}

export class InspectorClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    getCurrentUser(): Promise<Inspector | null> {
        let url_ = this.baseUrl + "/api/Inspector/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetCurrentUser(_response));
        });
    }

    protected processGetCurrentUser(response: Response): Promise<Inspector | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Inspector.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Inspector | null>(<any>null);
    }

    put(value: Inspector): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Inspector/me";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(value);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPut(_response));
        });
    }

    protected processPut(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }
}

export class MeasureAnswerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    get(id: string | null): Promise<MeasureQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/MeasureAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<MeasureQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MeasureQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MeasureQuestionAnswer | null>(<any>null);
    }

    create(id: string | null, answer: MeasureQuestionAnswer): Promise<MeasureQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/MeasureAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<MeasureQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MeasureQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MeasureQuestionAnswer | null>(<any>null);
    }

    edit(id: string | null, answerposted: MeasureQuestionAnswer): Promise<MeasureQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/MeasureAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answerposted);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<MeasureQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MeasureQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MeasureQuestionAnswer | null>(<any>null);
    }
}

export class MultipleChoiceAnswerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    get(id: string | null): Promise<MultipleChoiceQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/MultipleChoiceAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<MultipleChoiceQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MultipleChoiceQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MultipleChoiceQuestionAnswer | null>(<any>null);
    }

    create(id: string | null, answer: MultipleChoiceQuestionAnswer): Promise<MultipleChoiceQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/MultipleChoiceAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<MultipleChoiceQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MultipleChoiceQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MultipleChoiceQuestionAnswer | null>(<any>null);
    }

    edit(id: string | null, answerposted: MultipleChoiceQuestionAnswer): Promise<MultipleChoiceQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/MultipleChoiceAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answerposted);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<MultipleChoiceQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MultipleChoiceQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MultipleChoiceQuestionAnswer | null>(<any>null);
    }
}

export class OpenAnswerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    get(id: string | null): Promise<OpenQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/OpenAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<OpenQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OpenQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenQuestionAnswer | null>(<any>null);
    }

    create(id: string | null, answer: OpenQuestionAnswer): Promise<OpenQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/OpenAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<OpenQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OpenQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenQuestionAnswer | null>(<any>null);
    }

    edit(id: string | null, answerposted: OpenQuestionAnswer): Promise<OpenQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/OpenAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answerposted);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<OpenQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OpenQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenQuestionAnswer | null>(<any>null);
    }
}

export class PictureAnswerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    get(id: string | null): Promise<PictureQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/PictureAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<PictureQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PictureQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PictureQuestionAnswer | null>(<any>null);
    }

    create(id: string | null, answer: PictureQuestionAnswer): Promise<PictureQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/PictureAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<PictureQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PictureQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PictureQuestionAnswer | null>(<any>null);
    }

    edit(id: string | null, answerposted: PictureQuestionAnswer): Promise<PictureQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/PictureAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answerposted);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<PictureQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PictureQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PictureQuestionAnswer | null>(<any>null);
    }
}

export class QuestionnaireClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    getAll(): Promise<Questionnaire[] | null> {
        let url_ = this.baseUrl + "/api/Questionnaire";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetAll(_response));
        });
    }

    protected processGetAll(response: Response): Promise<Questionnaire[] | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Questionnaire.fromJS(item));
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Questionnaire[] | null>(<any>null);
    }

    changeComment(id: string | null, comment: string): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Questionnaire/{id}/description";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(comment);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processChangeComment(_response));
        });
    }

    protected processChangeComment(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    getComment(id: string | null): Promise<string | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/{id}/description";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGetComment(_response));
        });
    }

    protected processGetComment(response: Response): Promise<string | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string | null>(<any>null);
    }

    get(id: string | null): Promise<Questionnaire | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<Questionnaire | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? Questionnaire.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Questionnaire | null>(<any>null);
    }

    openQuestion(): Promise<OpenQuestion | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/open";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processOpenQuestion(_response));
        });
    }

    protected processOpenQuestion(response: Response): Promise<OpenQuestion | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OpenQuestion.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<OpenQuestion | null>(<any>null);
    }

    multipleChoiceQuestion(): Promise<MultipleChoiceQuestion | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/multiple";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMultipleChoiceQuestion(_response));
        });
    }

    protected processMultipleChoiceQuestion(response: Response): Promise<MultipleChoiceQuestion | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MultipleChoiceQuestion.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MultipleChoiceQuestion | null>(<any>null);
    }

    drawQuestion(): Promise<DrawQuestion | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/draw";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processDrawQuestion(_response));
        });
    }

    protected processDrawQuestion(response: Response): Promise<DrawQuestion | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? DrawQuestion.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DrawQuestion | null>(<any>null);
    }

    measureQuestion(): Promise<MeasureQuestion | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/measure";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processMeasureQuestion(_response));
        });
    }

    protected processMeasureQuestion(response: Response): Promise<MeasureQuestion | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? MeasureQuestion.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<MeasureQuestion | null>(<any>null);
    }

    pictureQuestion(): Promise<PictureQuestion | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/picture";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processPictureQuestion(_response));
        });
    }

    protected processPictureQuestion(response: Response): Promise<PictureQuestion | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PictureQuestion.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<PictureQuestion | null>(<any>null);
    }

    scaleQuestion(): Promise<ScaleQuestion | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/scale";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processScaleQuestion(_response));
        });
    }

    protected processScaleQuestion(response: Response): Promise<ScaleQuestion | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScaleQuestion.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScaleQuestion | null>(<any>null);
    }

    tableQuestion(): Promise<TableQuestion | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/table";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTableQuestion(_response));
        });
    }

    protected processTableQuestion(response: Response): Promise<TableQuestion | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TableQuestion.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TableQuestion | null>(<any>null);
    }

    categoryQuestion(): Promise<CategorieQuestion | null> {
        let url_ = this.baseUrl + "/api/Questionnaire/category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCategoryQuestion(_response));
        });
    }

    protected processCategoryQuestion(response: Response): Promise<CategorieQuestion | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CategorieQuestion.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<CategorieQuestion | null>(<any>null);
    }
}

export class ScaleAnswerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    get(id: string | null): Promise<ScaleQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/ScaleAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<ScaleQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScaleQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScaleQuestionAnswer | null>(<any>null);
    }

    create(id: string | null, answer: ScaleQuestionAnswer): Promise<ScaleQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/ScaleAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<ScaleQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScaleQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScaleQuestionAnswer | null>(<any>null);
    }

    edit(id: string | null, answerposted: ScaleQuestionAnswer): Promise<ScaleQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/ScaleAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answerposted);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<ScaleQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? ScaleQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ScaleQuestionAnswer | null>(<any>null);
    }
}

export class TableAnswerClient extends ApiClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: AuthClient, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : this.getBaseUrl("https://festiapi.azurewebsites.net");
    }

    get(id: string | null): Promise<TableQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/TableAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processGet(_response));
        });
    }

    protected processGet(response: Response): Promise<TableQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TableQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TableQuestionAnswer | null>(<any>null);
    }

    create(id: string | null, answer: TableQuestionAnswer): Promise<TableQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/TableAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answer);

        let options_ = <RequestInit>{
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processCreate(_response));
        });
    }

    protected processCreate(response: Response): Promise<TableQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TableQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TableQuestionAnswer | null>(<any>null);
    }

    edit(id: string | null, answerposted: TableQuestionAnswer): Promise<TableQuestionAnswer | null> {
        let url_ = this.baseUrl + "/api/TableAnswer/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(answerposted);

        let options_ = <RequestInit>{
            body: content_,
            method: "PUT",
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processEdit(_response));
        });
    }

    protected processEdit(response: Response): Promise<TableQuestionAnswer | null> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? TableQuestionAnswer.fromJS(resultData200) : <any>null;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TableQuestionAnswer | null>(<any>null);
    }
}

export abstract class EntityData implements IEntityData {
    id?: string | undefined;
    version?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    deleted?: boolean;

    constructor(data?: IEntityData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.id = data["id"];
            this.version = data["version"];
            this.createdAt = data["createdAt"] ? new Date(data["createdAt"].toString()) : <any>undefined;
            this.updatedAt = data["updatedAt"] ? new Date(data["updatedAt"].toString()) : <any>undefined;
            this.deleted = data["deleted"];
        }
    }

    static fromJS(data: any): EntityData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'EntityData' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["version"] = this.version;
        data["createdAt"] = this.createdAt ? this.createdAt.toISOString() : <any>undefined;
        data["updatedAt"] = this.updatedAt ? this.updatedAt.toISOString() : <any>undefined;
        data["deleted"] = this.deleted;
        return data; 
    }
}

export interface IEntityData {
    id?: string | undefined;
    version?: string | undefined;
    createdAt?: Date | undefined;
    updatedAt?: Date | undefined;
    deleted?: boolean;
}

export class AbstractEntity extends EntityData implements IAbstractEntity {

    constructor(data?: IAbstractEntity) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): AbstractEntity {
        data = typeof data === 'object' ? data : {};
        let result = new AbstractEntity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IAbstractEntity extends IEntityData {
}

export class Availability extends AbstractEntity implements IAvailability {
    inspector?: Inspector | undefined;
    event?: Event | undefined;
    eventId?: string | undefined;
    inspectorId?: string | undefined;
    eventDay!: number;
    hasResponded?: boolean;
    isAvailable?: boolean;

    constructor(data?: IAvailability) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.inspector = data["inspector"] ? Inspector.fromJS(data["inspector"]) : <any>undefined;
            this.event = data["event"] ? Event.fromJS(data["event"]) : <any>undefined;
            this.eventId = data["eventId"];
            this.inspectorId = data["inspectorId"];
            this.eventDay = data["eventDay"];
            this.hasResponded = data["hasResponded"];
            this.isAvailable = data["isAvailable"];
        }
    }

    static fromJS(data: any): Availability {
        data = typeof data === 'object' ? data : {};
        let result = new Availability();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["inspector"] = this.inspector ? this.inspector.toJSON() : <any>undefined;
        data["event"] = this.event ? this.event.toJSON() : <any>undefined;
        data["eventId"] = this.eventId;
        data["inspectorId"] = this.inspectorId;
        data["eventDay"] = this.eventDay;
        data["hasResponded"] = this.hasResponded;
        data["isAvailable"] = this.isAvailable;
        super.toJSON(data);
        return data; 
    }
}

export interface IAvailability extends IAbstractEntity {
    inspector?: Inspector | undefined;
    event?: Event | undefined;
    eventId?: string | undefined;
    inspectorId?: string | undefined;
    eventDay: number;
    hasResponded?: boolean;
    isAvailable?: boolean;
}

export class User extends AbstractEntity implements IUser {
    birthDate?: Date;
    gender?: Gender;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    role?: Role;

    constructor(data?: IUser) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.birthDate = data["birthDate"] ? new Date(data["birthDate"].toString()) : <any>undefined;
            this.gender = data["gender"];
            this.firstName = data["firstName"];
            this.lastName = data["lastName"];
            this.email = data["email"];
            this.phone = data["phone"];
            this.role = data["role"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["phone"] = this.phone;
        data["role"] = this.role;
        super.toJSON(data);
        return data; 
    }
}

export interface IUser extends IAbstractEntity {
    birthDate?: Date;
    gender?: Gender;
    firstName?: string | undefined;
    lastName?: string | undefined;
    email?: string | undefined;
    phone?: string | undefined;
    role?: Role;
}

export class Inspector extends User implements IInspector {
    questionnaireInspectors?: QuestionnaireInspector[] | undefined;
    geodanAdresId?: string | undefined;
    houseNumber!: string;
    postalCode!: string;
    locy?: number;
    locx?: number;

    constructor(data?: IInspector) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["questionnaireInspectors"] && data["questionnaireInspectors"].constructor === Array) {
                this.questionnaireInspectors = [] as any;
                for (let item of data["questionnaireInspectors"])
                    this.questionnaireInspectors!.push(QuestionnaireInspector.fromJS(item));
            }
            this.geodanAdresId = data["geodanAdresId"];
            this.houseNumber = data["houseNumber"];
            this.postalCode = data["postalCode"];
            this.locy = data["locy"];
            this.locx = data["locx"];
        }
    }

    static fromJS(data: any): Inspector {
        data = typeof data === 'object' ? data : {};
        let result = new Inspector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.questionnaireInspectors && this.questionnaireInspectors.constructor === Array) {
            data["questionnaireInspectors"] = [];
            for (let item of this.questionnaireInspectors)
                data["questionnaireInspectors"].push(item.toJSON());
        }
        data["geodanAdresId"] = this.geodanAdresId;
        data["houseNumber"] = this.houseNumber;
        data["postalCode"] = this.postalCode;
        data["locy"] = this.locy;
        data["locx"] = this.locx;
        super.toJSON(data);
        return data; 
    }
}

export interface IInspector extends IUser {
    questionnaireInspectors?: QuestionnaireInspector[] | undefined;
    geodanAdresId?: string | undefined;
    houseNumber: string;
    postalCode: string;
    locy?: number;
    locx?: number;
}

export class QuestionnaireInspector implements IQuestionnaireInspector {
    questionnaire?: Questionnaire | undefined;
    questionnaireId?: string | undefined;
    inspector?: Inspector | undefined;
    inspectorId?: string | undefined;
    comment?: string | undefined;

    constructor(data?: IQuestionnaireInspector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.questionnaire = data["questionnaire"] ? Questionnaire.fromJS(data["questionnaire"]) : <any>undefined;
            this.questionnaireId = data["questionnaireId"];
            this.inspector = data["inspector"] ? Inspector.fromJS(data["inspector"]) : <any>undefined;
            this.inspectorId = data["inspectorId"];
            this.comment = data["comment"];
        }
    }

    static fromJS(data: any): QuestionnaireInspector {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionnaireInspector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionnaire"] = this.questionnaire ? this.questionnaire.toJSON() : <any>undefined;
        data["questionnaireId"] = this.questionnaireId;
        data["inspector"] = this.inspector ? this.inspector.toJSON() : <any>undefined;
        data["inspectorId"] = this.inspectorId;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IQuestionnaireInspector {
    questionnaire?: Questionnaire | undefined;
    questionnaireId?: string | undefined;
    inspector?: Inspector | undefined;
    inspectorId?: string | undefined;
    comment?: string | undefined;
}

export class Questionnaire extends AbstractEntity implements IQuestionnaire {
    questions?: Question[] | undefined;
    name!: string;
    theme!: string;
    eventId?: string | undefined;
    description!: string;

    constructor(data?: IQuestionnaire) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["questions"] && data["questions"].constructor === Array) {
                this.questions = [] as any;
                for (let item of data["questions"])
                    this.questions!.push(Question.fromJS(item));
            }
            this.name = data["name"];
            this.theme = data["theme"];
            this.eventId = data["eventId"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): Questionnaire {
        data = typeof data === 'object' ? data : {};
        let result = new Questionnaire();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.questions && this.questions.constructor === Array) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        data["name"] = this.name;
        data["theme"] = this.theme;
        data["eventId"] = this.eventId;
        data["description"] = this.description;
        super.toJSON(data);
        return data; 
    }
}

export interface IQuestionnaire extends IAbstractEntity {
    questions?: Question[] | undefined;
    name: string;
    theme: string;
    eventId?: string | undefined;
    description: string;
}

export abstract class Question extends AbstractEntity implements IQuestion {
    questionnaireId?: string | undefined;
    description!: string;
    order?: number;

    protected _discriminator: string;

    constructor(data?: IQuestion) {
        super(data);
        this._discriminator = "Question";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.questionnaireId = data["questionnaireId"];
            this.description = data["description"];
            this.order = data["order"];
        }
    }

    static fromJS(data: any): Question {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "CategorieQuestion") {
            let result = new CategorieQuestion();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "OpenQuestion") {
            let result = new OpenQuestion();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MultipleChoiceQuestion") {
            let result = new MultipleChoiceQuestion();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "DrawQuestion") {
            let result = new DrawQuestion();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MeasureQuestion") {
            let result = new MeasureQuestion();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PictureQuestion") {
            let result = new PictureQuestion();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScaleQuestion") {
            let result = new ScaleQuestion();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TableQuestion") {
            let result = new TableQuestion();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Question' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator; 
        data["questionnaireId"] = this.questionnaireId;
        data["description"] = this.description;
        data["order"] = this.order;
        super.toJSON(data);
        return data; 
    }
}

export interface IQuestion extends IAbstractEntity {
    questionnaireId?: string | undefined;
    description: string;
    order?: number;
}

export class CategorieQuestion extends Question implements ICategorieQuestion {

    constructor(data?: ICategorieQuestion) {
        super(data);
        this._discriminator = "CategorieQuestion";
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): CategorieQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new CategorieQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICategorieQuestion extends IQuestion {
}

export enum Gender {
    Man = 0, 
    Vrouw = 1, 
    Overig = 2, 
}

export enum Role {
    Inspector = 0, 
    Manager = 1, 
    Operational = 2, 
    Sales = 3, 
}

export class Event extends AbstractEntity implements IEvent {
    startDate!: Date;
    endDate!: Date;
    customerId?: string | undefined;
    name!: string;
    description?: string | undefined;
    location!: string;
    houseNumber!: string;
    postalCode!: string;
    geodanAdresId?: string | undefined;
    geodanAdresX?: string | undefined;
    geodanAdresY?: string | undefined;

    constructor(data?: IEvent) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.startDate = data["startDate"] ? new Date(data["startDate"].toString()) : <any>undefined;
            this.endDate = data["endDate"] ? new Date(data["endDate"].toString()) : <any>undefined;
            this.customerId = data["customerId"];
            this.name = data["name"];
            this.description = data["description"];
            this.location = data["location"];
            this.houseNumber = data["houseNumber"];
            this.postalCode = data["postalCode"];
            this.geodanAdresId = data["geodanAdresId"];
            this.geodanAdresX = data["geodanAdresX"];
            this.geodanAdresY = data["geodanAdresY"];
        }
    }

    static fromJS(data: any): Event {
        data = typeof data === 'object' ? data : {};
        let result = new Event();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["customerId"] = this.customerId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["location"] = this.location;
        data["houseNumber"] = this.houseNumber;
        data["postalCode"] = this.postalCode;
        data["geodanAdresId"] = this.geodanAdresId;
        data["geodanAdresX"] = this.geodanAdresX;
        data["geodanAdresY"] = this.geodanAdresY;
        super.toJSON(data);
        return data; 
    }
}

export interface IEvent extends IAbstractEntity {
    startDate: Date;
    endDate: Date;
    customerId?: string | undefined;
    name: string;
    description?: string | undefined;
    location: string;
    houseNumber: string;
    postalCode: string;
    geodanAdresId?: string | undefined;
    geodanAdresX?: string | undefined;
    geodanAdresY?: string | undefined;
}

export abstract class Answer extends AbstractEntity implements IAnswer {
    questionId?: string | undefined;
    inspectorId?: string | undefined;

    protected _discriminator: string;

    constructor(data?: IAnswer) {
        super(data);
        this._discriminator = "Answer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.questionId = data["questionId"];
            this.inspectorId = data["inspectorId"];
        }
    }

    static fromJS(data: any): Answer {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "DrawQuestionAnswer") {
            let result = new DrawQuestionAnswer();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MeasureQuestionAnswer") {
            let result = new MeasureQuestionAnswer();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "MultipleChoiceQuestionAnswer") {
            let result = new MultipleChoiceQuestionAnswer();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "OpenQuestionAnswer") {
            let result = new OpenQuestionAnswer();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "PictureQuestionAnswer") {
            let result = new PictureQuestionAnswer();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "ScaleQuestionAnswer") {
            let result = new ScaleQuestionAnswer();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TableQuestionAnswer") {
            let result = new TableQuestionAnswer();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'Answer' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator; 
        data["questionId"] = this.questionId;
        data["inspectorId"] = this.inspectorId;
        super.toJSON(data);
        return data; 
    }
}

export interface IAnswer extends IAbstractEntity {
    questionId?: string | undefined;
    inspectorId?: string | undefined;
}

export class DrawQuestionAnswer extends Answer implements IDrawQuestionAnswer {
    imageUrl!: string;

    constructor(data?: IDrawQuestionAnswer) {
        super(data);
        this._discriminator = "DrawQuestionAnswer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.imageUrl = data["imageUrl"];
        }
    }

    static fromJS(data: any): DrawQuestionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new DrawQuestionAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageUrl"] = this.imageUrl;
        super.toJSON(data);
        return data; 
    }
}

export interface IDrawQuestionAnswer extends IAnswer {
    imageUrl: string;
}

export class MeasureQuestionAnswer extends Answer implements IMeasureQuestionAnswer {
    value?: number;

    constructor(data?: IMeasureQuestionAnswer) {
        super(data);
        this._discriminator = "MeasureQuestionAnswer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["value"];
        }
    }

    static fromJS(data: any): MeasureQuestionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new MeasureQuestionAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IMeasureQuestionAnswer extends IAnswer {
    value?: number;
}

export class MultipleChoiceQuestionAnswer extends Answer implements IMultipleChoiceQuestionAnswer {
    chosenOption?: MultipleChoiceQuestionOption | undefined;

    constructor(data?: IMultipleChoiceQuestionAnswer) {
        super(data);
        this._discriminator = "MultipleChoiceQuestionAnswer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.chosenOption = data["chosenOption"] ? MultipleChoiceQuestionOption.fromJS(data["chosenOption"]) : <any>undefined;
        }
    }

    static fromJS(data: any): MultipleChoiceQuestionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleChoiceQuestionAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["chosenOption"] = this.chosenOption ? this.chosenOption.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface IMultipleChoiceQuestionAnswer extends IAnswer {
    chosenOption?: MultipleChoiceQuestionOption | undefined;
}

export class MultipleChoiceQuestionOption extends AbstractEntity implements IMultipleChoiceQuestionOption {
    questionId?: string | undefined;
    value?: string | undefined;

    constructor(data?: IMultipleChoiceQuestionOption) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.questionId = data["questionId"];
            this.value = data["value"];
        }
    }

    static fromJS(data: any): MultipleChoiceQuestionOption {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleChoiceQuestionOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["questionId"] = this.questionId;
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IMultipleChoiceQuestionOption extends IAbstractEntity {
    questionId?: string | undefined;
    value?: string | undefined;
}

export class OpenQuestionAnswer extends Answer implements IOpenQuestionAnswer {
    answer!: string;

    constructor(data?: IOpenQuestionAnswer) {
        super(data);
        this._discriminator = "OpenQuestionAnswer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.answer = data["answer"];
        }
    }

    static fromJS(data: any): OpenQuestionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new OpenQuestionAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answer"] = this.answer;
        super.toJSON(data);
        return data; 
    }
}

export interface IOpenQuestionAnswer extends IAnswer {
    answer: string;
}

export class PictureQuestionAnswer extends Answer implements IPictureQuestionAnswer {
    imageUrl!: string;
    description?: string | undefined;

    constructor(data?: IPictureQuestionAnswer) {
        super(data);
        this._discriminator = "PictureQuestionAnswer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.imageUrl = data["imageUrl"];
            this.description = data["description"];
        }
    }

    static fromJS(data: any): PictureQuestionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new PictureQuestionAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["imageUrl"] = this.imageUrl;
        data["description"] = this.description;
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureQuestionAnswer extends IAnswer {
    imageUrl: string;
    description?: string | undefined;
}

export class OpenQuestion extends Question implements IOpenQuestion {

    constructor(data?: IOpenQuestion) {
        super(data);
        this._discriminator = "OpenQuestion";
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): OpenQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new OpenQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IOpenQuestion extends IQuestion {
}

export class MultipleChoiceQuestion extends Question implements IMultipleChoiceQuestion {
    options?: MultipleChoiceQuestionOption[] | undefined;

    constructor(data?: IMultipleChoiceQuestion) {
        super(data);
        this._discriminator = "MultipleChoiceQuestion";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [] as any;
                for (let item of data["options"])
                    this.options!.push(MultipleChoiceQuestionOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MultipleChoiceQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new MultipleChoiceQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IMultipleChoiceQuestion extends IQuestion {
    options?: MultipleChoiceQuestionOption[] | undefined;
}

export class DrawQuestion extends Question implements IDrawQuestion {
    pictureUrl?: string | undefined;

    constructor(data?: IDrawQuestion) {
        super(data);
        this._discriminator = "DrawQuestion";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.pictureUrl = data["pictureUrl"];
        }
    }

    static fromJS(data: any): DrawQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new DrawQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pictureUrl"] = this.pictureUrl;
        super.toJSON(data);
        return data; 
    }
}

export interface IDrawQuestion extends IQuestion {
    pictureUrl?: string | undefined;
}

export class MeasureQuestion extends Question implements IMeasureQuestion {
    unit!: string;

    constructor(data?: IMeasureQuestion) {
        super(data);
        this._discriminator = "MeasureQuestion";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.unit = data["unit"];
        }
    }

    static fromJS(data: any): MeasureQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new MeasureQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["unit"] = this.unit;
        super.toJSON(data);
        return data; 
    }
}

export interface IMeasureQuestion extends IQuestion {
    unit: string;
}

export class PictureQuestion extends Question implements IPictureQuestion {

    constructor(data?: IPictureQuestion) {
        super(data);
        this._discriminator = "PictureQuestion";
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): PictureQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new PictureQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface IPictureQuestion extends IQuestion {
}

export class ScaleQuestion extends Question implements IScaleQuestion {
    min!: number;
    max!: number;

    constructor(data?: IScaleQuestion) {
        super(data);
        this._discriminator = "ScaleQuestion";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.min = data["min"];
            this.max = data["max"];
        }
    }

    static fromJS(data: any): ScaleQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new ScaleQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["min"] = this.min;
        data["max"] = this.max;
        super.toJSON(data);
        return data; 
    }
}

export interface IScaleQuestion extends IQuestion {
    min: number;
    max: number;
}

export class TableQuestion extends Question implements ITableQuestion {
    keyColumn?: TableQuestionColumn | undefined;
    keyColumnId?: string | undefined;
    valueColumn?: TableQuestionColumn | undefined;
    valueColumnId?: string | undefined;

    constructor(data?: ITableQuestion) {
        super(data);
        this._discriminator = "TableQuestion";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.keyColumn = data["keyColumn"] ? TableQuestionColumn.fromJS(data["keyColumn"]) : <any>undefined;
            this.keyColumnId = data["keyColumnId"];
            this.valueColumn = data["valueColumn"] ? TableQuestionColumn.fromJS(data["valueColumn"]) : <any>undefined;
            this.valueColumnId = data["valueColumnId"];
        }
    }

    static fromJS(data: any): TableQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["keyColumn"] = this.keyColumn ? this.keyColumn.toJSON() : <any>undefined;
        data["keyColumnId"] = this.keyColumnId;
        data["valueColumn"] = this.valueColumn ? this.valueColumn.toJSON() : <any>undefined;
        data["valueColumnId"] = this.valueColumnId;
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestion extends IQuestion {
    keyColumn?: TableQuestionColumn | undefined;
    keyColumnId?: string | undefined;
    valueColumn?: TableQuestionColumn | undefined;
    valueColumnId?: string | undefined;
}

export abstract class TableQuestionColumn extends AbstractEntity implements ITableQuestionColumn {
    header!: string;

    protected _discriminator: string;

    constructor(data?: ITableQuestionColumn) {
        super(data);
        this._discriminator = "TableQuestionColumn";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.header = data["header"];
        }
    }

    static fromJS(data: any): TableQuestionColumn {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "TableQuestionStringColumn") {
            let result = new TableQuestionStringColumn();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TableQuestionMultipleColumn") {
            let result = new TableQuestionMultipleColumn();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TableQuestionNumberColumn") {
            let result = new TableQuestionNumberColumn();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TableQuestionTimeColumn") {
            let result = new TableQuestionTimeColumn();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'TableQuestionColumn' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator; 
        data["header"] = this.header;
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionColumn extends IAbstractEntity {
    header: string;
}

export class TableQuestionStringColumn extends TableQuestionColumn implements ITableQuestionStringColumn {

    constructor(data?: ITableQuestionStringColumn) {
        super(data);
        this._discriminator = "TableQuestionStringColumn";
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): TableQuestionStringColumn {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionStringColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionStringColumn extends ITableQuestionColumn {
}

export class TableQuestionMultipleColumn extends TableQuestionColumn implements ITableQuestionMultipleColumn {
    options?: MultipleChoiceQuestionOption[] | undefined;

    constructor(data?: ITableQuestionMultipleColumn) {
        super(data);
        this._discriminator = "TableQuestionMultipleColumn";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["options"] && data["options"].constructor === Array) {
                this.options = [] as any;
                for (let item of data["options"])
                    this.options!.push(MultipleChoiceQuestionOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TableQuestionMultipleColumn {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionMultipleColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.options && this.options.constructor === Array) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionMultipleColumn extends ITableQuestionColumn {
    options?: MultipleChoiceQuestionOption[] | undefined;
}

export class TableQuestionNumberColumn extends TableQuestionColumn implements ITableQuestionNumberColumn {

    constructor(data?: ITableQuestionNumberColumn) {
        super(data);
        this._discriminator = "TableQuestionNumberColumn";
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): TableQuestionNumberColumn {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionNumberColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionNumberColumn extends ITableQuestionColumn {
}

export class TableQuestionTimeColumn extends TableQuestionColumn implements ITableQuestionTimeColumn {

    constructor(data?: ITableQuestionTimeColumn) {
        super(data);
        this._discriminator = "TableQuestionTimeColumn";
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): TableQuestionTimeColumn {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionTimeColumn();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionTimeColumn extends ITableQuestionColumn {
}

export class ScaleQuestionAnswer extends Answer implements IScaleQuestionAnswer {
    value?: number;

    constructor(data?: IScaleQuestionAnswer) {
        super(data);
        this._discriminator = "ScaleQuestionAnswer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.value = data["value"];
        }
    }

    static fromJS(data: any): ScaleQuestionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new ScaleQuestionAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["value"] = this.value;
        super.toJSON(data);
        return data; 
    }
}

export interface IScaleQuestionAnswer extends IAnswer {
    value?: number;
}

export class TableQuestionAnswer extends Answer implements ITableQuestionAnswer {
    answerEntries?: TableQuestionAnswerEntry[] | undefined;

    constructor(data?: ITableQuestionAnswer) {
        super(data);
        this._discriminator = "TableQuestionAnswer";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            if (data["answerEntries"] && data["answerEntries"].constructor === Array) {
                this.answerEntries = [] as any;
                for (let item of data["answerEntries"])
                    this.answerEntries!.push(TableQuestionAnswerEntry.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TableQuestionAnswer {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionAnswer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.answerEntries && this.answerEntries.constructor === Array) {
            data["answerEntries"] = [];
            for (let item of this.answerEntries)
                data["answerEntries"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionAnswer extends IAnswer {
    answerEntries?: TableQuestionAnswerEntry[] | undefined;
}

export class TableQuestionAnswerEntry extends AbstractEntity implements ITableQuestionAnswerEntry {
    answerId?: string | undefined;
    key?: AbstractTableQuestionAnswerValue | undefined;
    value?: AbstractTableQuestionAnswerValue | undefined;

    constructor(data?: ITableQuestionAnswerEntry) {
        super(data);
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.answerId = data["answerId"];
            this.key = data["key"] ? AbstractTableQuestionAnswerValue.fromJS(data["key"]) : <any>undefined;
            this.value = data["value"] ? AbstractTableQuestionAnswerValue.fromJS(data["value"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TableQuestionAnswerEntry {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionAnswerEntry();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerId"] = this.answerId;
        data["key"] = this.key ? this.key.toJSON() : <any>undefined;
        data["value"] = this.value ? this.value.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionAnswerEntry extends IAbstractEntity {
    answerId?: string | undefined;
    key?: AbstractTableQuestionAnswerValue | undefined;
    value?: AbstractTableQuestionAnswerValue | undefined;
}

export abstract class AbstractTableQuestionAnswerValue extends AbstractEntity implements IAbstractTableQuestionAnswerValue {

    protected _discriminator: string;

    constructor(data?: IAbstractTableQuestionAnswerValue) {
        super(data);
        this._discriminator = "AbstractTableQuestionAnswerValue";
    }

    init(data?: any) {
        super.init(data);
    }

    static fromJS(data: any): AbstractTableQuestionAnswerValue {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "TableQuestionAnswerMultipleValue") {
            let result = new TableQuestionAnswerMultipleValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TableQuestionAnswerNumberValue") {
            let result = new TableQuestionAnswerNumberValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TableQuestionAnswerStringValue") {
            let result = new TableQuestionAnswerStringValue();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "TableQuestionAnswerTimeValue") {
            let result = new TableQuestionAnswerTimeValue();
            result.init(data);
            return result;
        }
        throw new Error("The abstract class 'AbstractTableQuestionAnswerValue' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator; 
        super.toJSON(data);
        return data; 
    }
}

export interface IAbstractTableQuestionAnswerValue extends IAbstractEntity {
}

export class TableQuestionAnswerMultipleValue extends AbstractTableQuestionAnswerValue implements ITableQuestionAnswerMultipleValue {
    answerValue?: MultipleChoiceQuestionOption | undefined;
    answerValueId?: string | undefined;

    constructor(data?: ITableQuestionAnswerMultipleValue) {
        super(data);
        this._discriminator = "TableQuestionAnswerMultipleValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.answerValue = data["answerValue"] ? MultipleChoiceQuestionOption.fromJS(data["answerValue"]) : <any>undefined;
            this.answerValueId = data["answerValueId"];
        }
    }

    static fromJS(data: any): TableQuestionAnswerMultipleValue {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionAnswerMultipleValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerValue"] = this.answerValue ? this.answerValue.toJSON() : <any>undefined;
        data["answerValueId"] = this.answerValueId;
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionAnswerMultipleValue extends IAbstractTableQuestionAnswerValue {
    answerValue?: MultipleChoiceQuestionOption | undefined;
    answerValueId?: string | undefined;
}

export class TableQuestionAnswerNumberValue extends AbstractTableQuestionAnswerValue implements ITableQuestionAnswerNumberValue {
    answerValue?: number;

    constructor(data?: ITableQuestionAnswerNumberValue) {
        super(data);
        this._discriminator = "TableQuestionAnswerNumberValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.answerValue = data["answerValue"];
        }
    }

    static fromJS(data: any): TableQuestionAnswerNumberValue {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionAnswerNumberValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerValue"] = this.answerValue;
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionAnswerNumberValue extends IAbstractTableQuestionAnswerValue {
    answerValue?: number;
}

export class TableQuestionAnswerStringValue extends AbstractTableQuestionAnswerValue implements ITableQuestionAnswerStringValue {
    answerValue?: string | undefined;

    constructor(data?: ITableQuestionAnswerStringValue) {
        super(data);
        this._discriminator = "TableQuestionAnswerStringValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.answerValue = data["answerValue"];
        }
    }

    static fromJS(data: any): TableQuestionAnswerStringValue {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionAnswerStringValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerValue"] = this.answerValue;
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionAnswerStringValue extends IAbstractTableQuestionAnswerValue {
    answerValue?: string | undefined;
}

export class TableQuestionAnswerTimeValue extends AbstractTableQuestionAnswerValue implements ITableQuestionAnswerTimeValue {
    answerValue?: Date;

    constructor(data?: ITableQuestionAnswerTimeValue) {
        super(data);
        this._discriminator = "TableQuestionAnswerTimeValue";
    }

    init(data?: any) {
        super.init(data);
        if (data) {
            this.answerValue = data["answerValue"] ? new Date(data["answerValue"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TableQuestionAnswerTimeValue {
        data = typeof data === 'object' ? data : {};
        let result = new TableQuestionAnswerTimeValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["answerValue"] = this.answerValue ? this.answerValue.toISOString() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ITableQuestionAnswerTimeValue extends IAbstractTableQuestionAnswerValue {
    answerValue?: Date;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if(result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}